ヘンリー・スペンサーの正規表現ライブラリに関する実装上の注意
============================================================

ヘンリーはこれまで内部資料を持っていても、公開していませんでした。したがって、
このファイルはいくつかのドキュメントをリバース・エンジニアリングする試みです。

一般的なソースファイルレイアウト
--------------------------------

6つの別々にコンパイル可能なソースファイルがあり、その内5つをエクスポート
した機能ずつ公開します:
	regcomp.c: pg_regcomp
	regexec.c: pg_regexec
	regerror.c: pg_regerror
	regfree.c: pg_regfree
	regprefix.c: pg_regprefix
(pg_ 接頭辞は特定のシステム上に存在するかもしれない任意の類似したものからこの
ライブラリのバージョンを区別する為にPostgresプロジェクトで追加されました。
彼らはライブラリを削除するか任意のスタンドアローンバージョンに置き換える必要が
あります。)

6番目のファイルregexport.cは、コンパイル済みの正規表現に関する情報の取り出しを
許可する複数の機能を公開します(regexport.hを参照)。

regcomp内の#includeに追加のソースファイルregc_*.cがあり、同様にregexec内の
#includeにも追加のソースファイルrege_*.cがあります。これは、グローバルに
内部シンボルのエクスポートを回避する為に行われました; 全ての機能は、静的な
ライブラリAPIの一部である事を意味するものではありません。

(実際には上記の1つはある点において嘘です: もう一つのグローバルシンボルが
regcompのpg_set_regex_collationにあります。APIの一部ではありませんが、
regcompとそれを呼び出すregexec両方がグローバルでなければなりません。
それを取り除くだけではなく、同様に静的変数を設定し、正規表現の構造に必要な
ロケール状態を維持するのにも良いと思います。我々はどの様にアプリケーション
固有の状態を構造に追加するかが設計不足の為にこれをまだ行っておりません。)

src/backend/regex/のどこに何が:

regcomp.c		最上位の正規表現のコンパイルコード
regc_color.c		カラーマップ管理
regc_cvec.c		文字ベクトル(cvec)管理
regc_lex.c		レクサ
regc_nfa.c		NFAの取り扱い
regc_locale.c		Tclプロジェクトからのアプリケーション固有のロケールコード
regc_pg_locale.c	Postgresに追加されたアプリケーション固有のロケールコード
regexec.c		最上位の正規表現の実行コード
rege_dfa.c		DFAの作成と実行
regerror.c		pg_regerror: 正規表現のエラーコードのテキストを生成
regfree.c		pg_regfree: 必要なくなったregex_tを解放するAPI
regexport.c		regex_tから情報を抽出する為の関数
regprefix.c		regex_tから共通の接頭辞を抽出する為のコード

ロケール固有のコードは主に大文字変換と[[:alnum:]]といったロケール固有の
文字クラスの拡張と関係しています。もし、これがスタンドアロンライブラリに
なるのであれば、それは本当にリファクタリングが必要となります。

src/include/regex/内にライブラリのヘッダファイルがあります:

regcustom.h		特定のアプリケーション用のカスタマイズライブラリ
regerrs.h		エラーメッセージリスト
regex.h			エクスポートされたAPI
regexport.h		regexport.cの為のエクスポートされたAPI
regguts.h		内部宣言


DFA, NFA及び全ての事
--------------------

このライブラリはハイブリッドDFA/NFAの正規表現の実装です。(あなたがそれらの
用語のどちらもこれまで聞かなかったならば、初年度無料の科学の教科書をあなたに
提供します。) それが何を本当に意味し、そして、それに関してコードで表示される
ものは、一見明確ではないかもしれません。ここでは本当に何が起こるかです:

* 正規表現の最初の解析は、正規表現の長さにほぼ比例した状態の数のNFA表現を
生成します。

* NFAは基本的には同じ考えであるが、実行時に必要とされていないフィールドなしの
"compact NFA"表現に最適化されています。それはあまりにも簡易化されています: 
コンパクトな形式は"plan"と"LACON"のアーカイブタイプのみ可能です。cNFA形式は
regcompからregexecまで渡されるものです。

* 従来のNFAベースの正規表現エンジンとは異なり、それはバックトラッキングが
必要となり、いくつかのケースで非常に遅くなりますので、NFA表現から直接実行
しないで下さい。むしろ、我々は理想的にはバックトラッキングなしに線形時間
(入力文字Mの為のOrder(M))で入力文字を処理する事が出来るDFAを実行します。
DFAの各状態はNFAの一組に対応し、それはNFAが入力文字列の現在の位置に達した時で
あったかもしれない全ての状態です。したがって、N個の状態のNFAは対応するDFAは
2^Nもの数の個の状態が必要な場合があり、これは容易に非合理的なメモリ量を必要と
する可能性があります。我々は、(必要な場合にのみ)ゆっくりとDFAの状態を実体化し、
限られたサイズのキャッシュでそれらを保つ事により、これに対処します。繰り返し
DFAの同じ状態を構築する必要があるのであれば、このアプローチはOrder(M)時間では
ありませんが、しかし、最悪のケースではOrder(M*N)となります。それでも、バック
トラッキングNFAエンジンの最悪のケースよりもまだはるかに良いです。

それはそれの終わりであれば、我々はNFAは単に実装の詳細との程度で利用して
DFAエンジンと言うでしょう。しかし、DFAエンジンは例えばキャプチャする括弧や
後方参照など、いくつかの重要な正規表現の機能を処理する事は出来ません。
パーサが正規表現でこれらの機能を利用しているの事を見付けた場合(総称して
コードでは"messy cases"と呼ばれます)、我々は結局、NFAスタイルのバック
トラッキング検索を使用する必要があります。

NFAモードを使用する場合、パーサによって構築される表現は下位式("subre")の
ツリーで構成されています。リーフツリーノードは、プレーンな正規表現(これは、
上記の様にDFAとして実行されます)または後方参照(いくつか前の部分に入力を一致
させようとします)のいずれかです。非リーフノードはキャプチャノード(それらの
子ノードに現在一致する部分文字列の位置を保存します)、連結、交互、反復ノード
です。実行時にエグゼキュータは再帰的にツリーをスキャンします。連結、交互、
反復ノードでは、それが入力文字列に一致するそれぞれ可能な代替方法を検討し、
その文字列を連結や反復、または交互の為の各子ノードの分割をそれぞれの場所で
する事が出来ます。子ノードで一致に失敗した場合は、次の代替手段をとります。
これはまさしく伝統的なNFA正規表現エンジンによって行われたバックトラッキング
検索の一種です。多くのツリーレベルがある場合、それは非常に遅くなります。

しかし、全てを失うわけではありません: 我々は平均的な純粋NFAエンジンより
賢くする事が出来ます。これを行うには、各subreノードは数学的に純粋な正規
表現がそれについて説明出来る限り、それはおそらくノードが一致する事が出来た
ものを表す関連するDFAを持っています。これは基本的に"no backrefs"を意味します。
我々は代替可能なサブマッチの任意の検索を実行する前に、我々はそれが提案されて
いる部分が一致するかどうかを確認する為にDFAが実行されます。そうでない場合、
我々は直ぐに多くの可能性を反復する事無く一致を拒否する事が出来ます。

例として、正規表現"(a[bc]+)\1"を検討して下さい。コンパイルされた表現は、
最上位階層の連結subreノードを持つ事になります。その左の子は、キャプチャ
ノードであり、その子は"a[bc]+"の為のプレーンDFAノードです。連結の右の子は
\1の為の後方参照ノードです。ここで、後方参照は参照先の表現の為に、DFAの
コピーに置き換えられ"a[bc]+a[bc]+"となり、DFAは連結ノードに関連付けられて
います。実行されると、連結ノードはそれぞれにその2つの子ノードは文字列の
その部分に一致する事が出来る入力文字列の可能な分割を検索する必要があります
(中間に分割がある時に、この特定のケースにのみ成功しますが、コードはそれを
知りませんし、一般的にも当てはまります)。しかしながら、我々は"a"から始めない
で、若干数の"b"と"c"をプラスし、もう1つ"a"を含んだ任意の入力だと即効拒否され、
最初からDFAを実行する事が出来ます。DFAが一致しない場合、可能性のある文字列
分割点の2つの子ノードに再帰する必要はありません。多くの場合、このプレフィルタ
リングは、純粋なNFAエンジンが行うよりもはるかに高速な検索を実行します。
それは、スペンサーのライブラリを説明する"hybrid DFA/NFA engine"というフレーズを
使用する事を正当化する動作です。


カラーとカラーマッピング
------------------------

多くの一般的な正規表現パターンでは、実行エンジンによって同様に処理する事が
出来る多数の文字があります。識別子の為の簡単な例は、パターン
"[[:alpha:]][[:alnum:]]*"です。基本的にはエンジンのみで入力記号は文字、数字、
またはその他であるかどうかを気にする必要があります。我々は、文字と数字の
可能性ごとに別々のアークをNFAまたはDFAで構築する事が出来ますが、それは数千の
文字を持つ事が出来るUnicodeを扱う場合は特に、非常にスペースの無駄でいずれかを
実行する事が安くはありません。その代わりに、パーサは各々の可能性がある入力
記号を"color"、または同値類をマップした"color map"を構築します。それから、
NFAやDFA表現ではカラーではなく特定の入力シンボルでラベルされたアークを持って
います。実行時にエグゼキューたが各入力シンボルで最初に行う事は、そのカラーを
カラーマップで調べる事で、それから他の全ては色だけで動作します。

カラーマップを構築する為に、我々は可能な全ての入力記号を"other"を意味する
カラーWHITEを割り当てる事によって開始します(つまり、構文解析時の終了時に
まだシンボルがWHITEであるなら、明示的に正規表現の正規表現のどこでも参照
されないものです)。我々は、単純なリテラル文字または正規表現でのブランケット
式を見ると、ブランケット式で表される文字または全ての文字に、この文字または
ブランケット式を一致させる為の状態遷移に対応するNFAアークをラベルするのに
用いる事が出来るユニークな新しいカラーを割り当てます。基本的な考え方は次の
通りです:第一に、いくつかの新しい値に文字に割り当てられたカラーを変更します;
第二に、部分的に構築されたNFAの全ての既存のアークを介して実行し、文字の古い
色をそれぞれについて参照し、その新しい色を参照する並列アークを追加します
(これは再割り当てが我々が既に構築されたものの意味を変えない様に保持します);
第三に、NFA状態の現在のペアに文字の新しいカラーで新しいアークを追加し、この
文字が表示されていても、状態遷移を行う事が可能な事を示して下さい。

これは、必要以上のカラー(同値類)を作成したくないことでビットが複雑になります。
特に、ブランケット式は前と同じカラーを持った2つの文字に言及するならば、彼ら
を識別する必要がまだ無い時から、我々がブランケットを処理した後に、彼らはまだ
同じカラーを共有しなければなりません。しかし、我々は以前に同じカラーを持って
いたが、まだブランケット式にリストされていない他の文字と識別する必要があります。
これを機械化する為に、コードには"parent colors"と"subcolors"の概念があり、
そこで、カラーのサブカラーには、現在の原子を解析している間に我々がそのカラーの
任意の文字に与えている新しいカラーがあります。(単語の"parent"は、長寿命の関係を
示唆していますが、サブカラーリンクは本当に一つの原子を解析する期間の間続くだけ
なので、少し残念です。) 言い換えると、サブリンクは各メンバの文字が現在の正規表現
原子に含まれるかどうかに応じて、我々がペアレントカラーを2色(同値類)に分ける処理で
ある事を意味します。

例として、我々は正規表現"a\d\wx"を持っていると仮定します。初めは全ての
可能性がある文字がWHITE(カラー0)とラベルされます。原子"a"を解析すると、
我々は新しいカラー(1)を作成し、"a"のカラーマップ項目を1にアップデートし、
NFAの2つの状態の間で1とラベルされたアークを作成します。今、我々は本当に
数字"0"-"9"を含むブランケット式である\dを見ます。まず最初に、我々は現在
WHITEである"0"を処理するので、新しいカラー(2)を作成し、"0"のカラーマップ
項目を2にアップデートし、NFAの2番目と3番目の状態の間で2とラベルされた
アークを作成します。我々は同様にサブカラー2を持つカラーWHITEをマークします、
それは、WHITE文字が将来ラベルの張替えで新しいカラーとして2を選択する必要が
ある事を意味します。したがって、我々は"1"を処理する時に、新しいカラーを
作成するのではなく、2を再利用します。我々は"1"のカラーマップ項目を2にアップ
デートし、次にNFAの2番目の状態と3番目の状態の間には2とラベルされたものが
既にありますので、新しくアークを作成する必要がない事に気付きます。他の8つの
数字についても同様に、このブランケット式の全てのメンバの為にNFAの状態2と3の
間に2とラベルされたアークだけがあります。ブランケット式の完了では、我々は
全ての既存のペアレント/サブカラーリンク破壊するokcolors()を呼び出す; WHITEの
文字が2の再ラベルする必要があっても、もはやマーカはありません。(注意: 実際に、
我々は初期の原子"a"の為のサブカラーリンクと同じに作成とクリアをしましたが、
とても興味深い事は何もありませんでした。) 我々は今"\w"のブランケット式になる
と、簡単にする為に単に"[a-z0-9]"と仮定し展開します。我々は"a"を処理するが、
それは既にそのカラー1唯一のメンバである事を監視します。これは、より細かく
その等価クラスを細分化する必要ないので、我々は新しいカラーを作成しない事を
意味します。我々はちょうどNFAの状態の3番目と4番目の間で1とラベルされたアークを
作ります。次に、我々はWHITEとWHITE文字に限った事ではない"b"を処理するので、
新しいカラー(3)を作成し、WHITEのサブカラーとして"b"をカラー3と再ラベルし、
アークをラベル3にします。我々が"z"を経由し"c"を処理するように、それぞれが3に
WHITEから再ラベルされていますが、新しいアークは必要ありません。今我々は"0"に
いて、カラー2の唯一のメンバではなく、新しいカラーが必要でカラー4を作成している
事とします。我々は、2のサブカラーを4とし、マップのカラー4を"0"に再ラベルし、
カラー4の為のアークを追加します。次に"9"から"1"は、同様にアークの追加の必要
なしにカラー4を再ラベルします。ブランケット式を終えて、我々はサブカラーの
リンクを破壊するのにokcolors()を呼び出します。okcolors()は、さらにまた我々は
カラー2(数字文字の前のカラー)の全てのメンバを削除した事を監視します。したがって、
これまでに構築された部分的なNFAを経由し、カラー4に2とラベルされたアークを
再ラベルします; 特にNFAの状態2から状態3へのアークは再ラベルされたカラー4です。
我々はそれらのカラーをこれ以上使用しないので、カラー2を解放します。現在、
数字の為の遷移するNFAが一貫してカラー4をラベルしています。最後に、我々は原子の
"x"を展開します。"x"は現在カラー3でラベルされており、それは、そのカラー唯一の
メンバではありませんので、我々は今、我々の前に行わなかった他の文字から"x"を区別
する必要があり、それを実現します。我々は5だったかも知れない新しいカラーを作成し、
その代わりに我々は未使用のカラー2をリサイクルします。"x"はカラーマップに2で再
ラベルされており、2は3のサブカラーとしてリンクされておりますので、我々はNFAの
状態4と5の間に2のアークを追加します。今、我々はokcolors()を呼び出し、カラー3と
2の間のサブカラーリンクを破壊し、両方のカラーが空でない事に気が付きます。
したがって、それも同様に既存のNFAのアークを通り、3とラベルされたアークが存在
していても、2とラベルされたアークを追加します; このアクションは、カラー2の文字
(i.e., "x")がまだ以前やっていた任意の遷移を許可し、それらを考慮している事を保証
しています。我々は今、正規表現の構文解析が完了し、これらの最終的なカラーが割り
当てられています:
	カラー 1: "a"
	カラー 2: "x"
	カラー 3: 他の文字
	カラー 4: 数字
そしてNFAのアーク:
	状態 1 -> 2 のカラー 1 (従って"a"のみ)
	状態 2 -> 3 のカラー 4 (数字)
	状態 3 -> 4 のカラー 1, 3, 4, と 2 (全ての \w 文字をカバー)
	状態 4 -> 5 のカラー 2 ("x"のみ)
これは正規表現の正確な表現である事が分かります。

この概要を考えると、カラーについては次の操作が必要である事がわかります:

* 任意の文字コードのカラー割り当てを高速に検索する方法。(これは解析と
  実行の両方が必要ですが、残りの操作は解析中にのみに必要です。)
* 任意の文字コードのカラー割り当てを変更する方法。
* 我々は空とシングルトンのカラーを検出出来る様に、現在の各カラーに割り
  当てられている文字数を追跡しなければなりません。
* 我々は既存のNFAアークの与えられたカラーを全て追跡し、必要に応じてそれ
  らを再ラベルするか、既存のカラーを細分化する時に新しいカラーのパラレル
  アークを追加しなければなりません。

これらの最後の2つは、NFAアークの構造体の"struct colordesc"配列と
"colorchain" リンクで処理します。本来のカラーマップ(つまり、文字単位の
ルックアップ配列)はマルチレベルツリーとして扱われ、各ツリーレベルは文字
の値の1バイトでインデックスされます。このコードでは、全てが同じカラーの
ボトムレベルのツリーページのコピーを2つ以上持たないように整えられています。

残念な事に、このデザインは全てのUnicode文字が同じカラーになっているツリー
のような一般的なケースでは非常に効率的ではなく、マップの終わりを除いて
ページ全体を同じカラーにする場所はあまりありません。(また、私はPGの現在の
Unicode値の範囲に対する制限を考慮し、4レベルツリーではなく、3レベルツリー
を使用しています; 現時点では、regguts.hにはその為の規定はありません。)

より大きな問題は、"\w"のような正規表現の正規表現解析時に、各Unicode文字を
別々に考慮する必要があるのが非常に妥当ではない事です。おそらく、これらの
コードの大部分は実行時に決して見る事はありません。ロケールベースの文字
クラスは、解析時に内容を完全に拡張する事なく何らかの形で"symbolically"に
処理されるように修正する必要があります。これは、実行時にiswalpha()を呼び
出す準備が整う必要がある事を意味しますが、ハイコード値の文字に対してのみ
発生する場合は、パフォーマンスが大幅に低下する事はありません。


NFAの詳細な意味
---------------

処分されたNFAを読む場合、これらの事実を知る事は役に立ちます:

状態0(dumpnfaの出力に"@"のマークが付いています)は常に目標状態であり、状態1
(加えて">"でマークされています)は開始状態である。(コードは、これらをそれぞれ
のポスト状態とプレ状態と呼びます。)

可能なアークの種類は次の通りです:

    与えられた"color"(上記参照)の任意の文字の一致を指定するPLAINアーク。
    これらは"[color_number]->to_state"としてダンプされます。

    他の状態へのノーオペレーション遷移を指定するEMPTYアーク。これらは
    "->to_state"としてダンプされます。

    "next character must be of this color"制約を表すAHEAD制約。AHEADは
    アークを横切る時に入力文字が消費されない点でPLAINアークとは異なります。
    これらは">color_number>->to_state"としてダンプされます。

    BEHIND制約は"previous character must be of this color"制約を表し、
    同様に入力を消費しません。これらは"<color_number<->to_state"として
    ダンプされます。

    '^'アークは、入力開始の制約を指定します。これらは"^0->to_state" or 
    "^1->to_state"としてダンプされ、それぞれ文字列の開始と行頭の制約の
    為のものです。

    '$'アークは、入力の終わりの制約を指定します。これらは"$0->to_state" 
    or "$1->to_state"としてダンプされ、それぞれ文字列の終わりと行末の
    制約の為のものです。

    LACON制約は"(?=re)" and "(?!re)" 制約を表し、即ちこの点から始まる
    入力は所定のサブREと一致(または、不一致)しなければならないが、一致
    する入力は消費されない。これらは":subtree_number:->to_state"として
    ダンプされます。

アークの表示に何か他のもの(特にどんな疑問符でも)がある場合は、アークについて
何かいかがわしいものがある事を伝えようとしているdumpnfa()です: ソースコードを
参照して下さい。

正規表現のエグゼキュータは、PLAINおよびLACON遷移のみを処理できます。正規表現で
optimize()関数は、パーサの出力を変換して他の全てのアークタイプを取り除く役割を
担います。特に^や$アークは削除する事が不可能なもので、常にプレまたはポスト状態
に隣接して終わり、そしてBOS、BOL、EOSまたはEOLの特殊な"colors"を表すPLAINアーク
に変換されます。

この様に変換されたNFAが入力文字列の指定された部分文字列と一致するかどうかを
判断する為に、実行プログラムは基本的に次の規則に従います:
1. 与えられた部分文字列 *before* から"looking at"し、NFAを開始するか部分
文字列が入力の最初にある場合は、架空のBOS文字を前に付加します。
2. 与えられた部分文字列 *after* を消費するまでNFAを実行し、部分文字列が
入力の最後にある場合は、架空のEOS文字を後に続けます。
3. この時点でNFAが目標状態(または、可能な状態)である場合、それは一致します。

つまり、入力の最初と最後に一致する通常の制約として^と$を取る事で変換されて
いないNFAを暗黙的に実行できます; 開始状態からのプレーンアークは、ターゲット
部分文字列の前の文字と一致している必要があり、同様にポスト状態に至るプレーン
アークは、ターゲット部分文字列の後ろの文字と一致します。この定義は\mや\Mの
様な制約で始まりまたは終わりの正規表現をサポートするのに必要であり、もし
あれば隣接する文字の必要条件を意味します。単純なアンアンカーパターンのNFAは
通常プレ状態のアウトアークの為にBOSとBOLだけでなく、全ての可能な文字カラーと
ポスト状態のインアークの為にEOSとEOLだけでなく、全ての可能な文字カラーを持ち、
エグゼキュータの動作が機能します。
